import { image, sendableImage } from '@kit.ImageKit';
import { common } from '@kit.AbilityKit';
import { AbsCameraReader, PixelMapFrameProducer,WriteHandle} from 'cameralib';
import { ScanningEffectCanvasDynamic,ScanningEffectCanvasStatic,ScanBoxInfo} from '../../component/view/ScanningEffectCanvas';
import { ScanningRectEffect} from '../../component/view/ScanningRectEffect';
import { worker, MessageEvents, ErrorEvent } from '@kit.ArkTS';
import { DecoderCameraParameters } from '../../decoder/DecoderCameraParameters';
import { BasePage } from '../../component/Page/BasePage';
import { display, promptAction, window } from '@kit.ArkUI';

import { BleManager } from '@ohos/fastble';
import { ImageDataMsg, InitMsg, DecodeResultMsg, WorkerPostMessageType } from '../../decoder/DecodeWorkerModel';
import { DecodeResultBean } from '../../bean/DecodeResultBean';
import { Logger } from 'common';
import { Decoder, OnDecodeResult } from '../../decoder/Decoder';

const TAG = 'CameraReaderTestPage'

@Entry
@Component
struct CameraReaderTestPage {
  @State mPixelMap: image.PixelMap | null = null;
  @State testResults: string = '';
  @State decodeResults: string = '';
  private mReader: AbsCameraReader | null = null;
  private mFrameProducer: PixelMapFrameProducer | null = null;
  //private decodeWorker: worker.ThreadWorker | null = null;
  private isWorkerRunning: boolean = false;

  private mPixelMapSendAble: sendableImage.PixelMap | null = null;

  private imageWidth:number = 1920
  private imageHeight:number = 1080

  private screenWidth: number = 0;
  private screenHeight: number = 0;

  private mDecoder: Decoder | null = null;

  @State themeColor: ResourceColor = '#FF0000';
  @State isQT: boolean= true
  @State timer: number = 0
  @State running: boolean = false
  private intervalId: number = 0
  private startTimer() {
    this.running = true
    this.intervalId = setInterval(() => {
      if (this.running) {
        this.timer++
      }
    }, 100)
  }
  private stopTimer() {
    this.running = false
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = 0
    }
  }

  //å¤„ç†è§£ç ç»“æœ
  private mDecodeResultListener: OnDecodeResult = {
    onDecoded: (data: DecodeResultBean, ok: boolean) => {
      const timestamp = new Date().toLocaleTimeString();
      if (ok && data.IsSuccess()) {
        this.decodeIndex++;
        this.decodeResults = `[${timestamp}] âœ… ${this.decodeIndex}è§£ç æˆåŠŸ${data.getCode()}\n` + this.decodeResults;
        promptAction.showToast({
          message: 'Workerè°ƒç”¨ZXingè§£ç æˆåŠŸï¼Œç»“æœä¸º:' + data.getCode(),
          duration: 2000
        });
      } else {
        this.decodeResults = `[${timestamp}] âŒ è§£ç å¤±è´¥\n` + this.decodeResults;
      }
    },
    onWorkerError: (error: ErrorEvent): void => {
      const timestamp = new Date().toLocaleTimeString();
      this.decodeResults = `[${timestamp}] âŒ workerå¼‚å¸¸:${error.message}\n` + this.decodeResults;
    },
    onWorkerInitted: (): void => {
      const timestamp = new Date().toLocaleTimeString();
      if (this.mReader) {
        this.mDecoder?.decode(this.mReader);
        this.decodeResults = `[${timestamp}] âœ… workeråˆå§‹åŒ–å®Œæˆ\n` + this.decodeResults;
      }
    },
    onHandleFrame: (frame: Uint8Array): void => {
      throw new Error('Function not implemented.');
    }
  };

  aboutToAppear() {
    const ctx = getContext(this) as common.UIAbilityContext;
    const resMgr = ctx.resourceManager;
    const rawFd = resMgr.getRawFdSync('2.jpg'); // è¿”å› RawFileDescriptor
    const imageSource = image.createImageSource(rawFd);
    let pixelMap = imageSource.createPixelMapSync();
    let size = imageSource.getImageInfoSync().size
    this.imageWidth = size.width
    this.imageHeight = size.height
    this.mPixelMap = pixelMap

    const croppedSize = pixelMap.getPixelBytesNumber();
    const readBuffer = new ArrayBuffer(croppedSize);
    pixelMap.readPixelsToBufferSync(readBuffer);
    let pixelMapInfo = pixelMap.getImageInfoSync();
    this.mPixelMapSendAble = sendableImage.createPixelMapSync(readBuffer,{ editable: true, size: pixelMapInfo.size,
      srcPixelFormat: pixelMapInfo.pixelFormat });

    this.startTimer()
    // åˆå§‹åŒ–æµ‹è¯•ç”¨çš„ AbsCameraReader
    this.initTestReader(size.width,size.height,image.PixelMapFormat.RGBA_8888);

    let displayClass: display.Display | null = null;
    displayClass = display.getDefaultDisplaySync();
    this.screenWidth = displayClass.width;//1260
    this.screenHeight = displayClass.height;//2720
    let availableWidth = displayClass.availableWidth
    let availableHeight= displayClass.availableHeight
    window.getLastWindow(getContext(this), (error, topWindow) => {
      if (topWindow) {
        let area = topWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
        let statusBarHeight = area.topRect.height
      }
    })
    // åˆå§‹åŒ–è§£ç  Worker
    this.initDecodeWorker();
  }

  testData:Uint8Array|null = null

  onPageHide(): void {
    clearTimeout(this.loopTimer);
    this.loopTimer = -1;
    // æ¸…ç†èµ„æº
    if (this.mDecoder) {
      this.mDecoder.releaseWorker();
    }
  }

  aboutToDisappear() {
    if(this.loopTimer) clearTimeout(this.loopTimer);
    this.loopTimer = -1;
    // æ¸…ç†èµ„æº
    if (this.mDecoder) {
      this.mDecoder.releaseWorker();
    }
  }

  private initTestReader(width:number,height:number,format:image.PixelMapFormat) {
    try {
      this.mReader = AbsCameraReader.getInstance(width, height, format, 3, 90, false);
      if(!this.mFrameProducer || this.mReader.consumeChanged()){
        this.mFrameProducer = new PixelMapFrameProducer(this.mReader);
      }
      this.appendResult('âœ… AbsCameraReader åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      this.appendResult(`âŒ AbsCameraReader åˆå§‹åŒ–å¤±è´¥: ${error}`);
    }
  }

  private decodeIndex = 0

  private initDecodeWorker() {
    try {
      this.mDecoder = Decoder.getInstance();
      this.mDecoder.start(this.mDecodeResultListener);
      this.appendResult('âœ… DecodeWorker åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      this.appendResult(`âŒ DecodeWorker åˆå§‹åŒ–å¤±è´¥: ${error}`);
    }
  }

  private appendResult(message: string) {
    const timestamp = new Date().toLocaleTimeString();
    this.testResults = `[${timestamp}] ${message}\n` + this.testResults;
  }

  // å¯åŠ¨è§£ç  Worker
  private startDecodeWorker() {
    try {
      if (this.mDecoder) {
        this.mDecoder.start(this.mDecodeResultListener);
        this.appendResult('âœ… DecodeWorker å·²å¼€å¯');
      }
    } catch (error) {
      this.appendResult(`âŒ å¯åŠ¨ DecodeWorker å¤±è´¥: ${error}`);
    }
  }

  // åœæ­¢è§£ç  Worker
  private stopDecodeWorker() {
    if (this.mDecoder) {
      this.mDecoder.stop();
      this.appendResult('âœ… DecodeWorker å·²åœæ­¢');
    }
  }

  private loopTimer?: number;
  // æµ‹è¯•FrameProducer
  private testPixelMap(){
    if (this.mFrameProducer && this.mPixelMapSendAble) {
      this.mFrameProducer.onFrame(this.mPixelMapSendAble);
      if(this.mReader)
        this.mDecoder?.decode(this.mReader)
    }
    this.loopTimer = setTimeout(() => { this.testPixelMap() },300)
  }

  // æµ‹è¯•1: å›¾ç‰‡åŠ è½½ä¸å¤„ç†
  private async testImageProcessing() {
    try {
      this.appendResult('ğŸ”„ å¼€å§‹å›¾ç‰‡å¤„ç†æµ‹è¯•...');

      const ctx = getContext(this) as common.UIAbilityContext;
      const resMgr = ctx.resourceManager;
      const rawFd = resMgr.getRawFdSync('baidu_qrcode.png');

      // åˆ›å»ºå›¾ç‰‡æº
      const imageSource = image.createImageSource(rawFd);
      let pixelMap = imageSource.createPixelMapSync();

      const originalSize = pixelMap.getPixelBytesNumber();
      this.appendResult(`ğŸ“ åŸå§‹å›¾ç‰‡å¤§å°: ${originalSize} bytes`);

      // è£å‰ªæµ‹è¯•
      pixelMap.cropSync({
        size: { width: 200, height: 200 },
        x: 200,
        y: 200
      });

      const croppedSize = pixelMap.getPixelBytesNumber();
      this.appendResult(`âœ‚ï¸ è£å‰ªåå¤§å°: ${croppedSize} bytes`);

      // è¯»å–åƒç´ æ•°æ®
      const readBuffer = new ArrayBuffer(croppedSize);
      pixelMap.readPixelsToBufferSync(readBuffer);
      this.appendResult(`âœ… åƒç´ æ•°æ®è¯»å–æˆåŠŸ: ${readBuffer.byteLength} bytes`);

      if(this.mPixelMapSendAble){
        // ç¡®ä¿ Worker å·²å¯åŠ¨
        if (this.mReader) {
          this.mDecoder?.decode(this.mReader);
        }
        this.mDecoder?.postMessageWithSharedSendable(this.mPixelMapSendAble);
      }

      this.mPixelMap = pixelMap;
      return readBuffer;

    } catch (error) {
      this.appendResult(`âŒ å›¾ç‰‡å¤„ç†æµ‹è¯•å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * Yè½´ä½ç½®å®‰å“ä¸º40%
   * */
  @State scanningEffectYPercent: number = 0.4;
  private scanBoxInfo :ScanBoxInfo |null = null;
  build() {
    Stack() {
      Column({ space: 20 }) {
        BasePage()

        Text('CameraReader + DecodeWorker æµ‹è¯•')
          .fontSize(24)
          .fontWeight(FontWeight.Bold)

        Text(`è®¡æ—¶å™¨: ${this.timer}`)
          .fontSize(30)
          .fontWeight(FontWeight.Bold)

        Row({ space: 10 }) {
          Button('ç›´æ¥Sendableè§£ç ')
            .onClick(() => this.testImageProcessing())

          Button('æ¨¡æ‹Ÿç›¸æœºå†™å…¥(QR)')
            .onClick(() => this.testPixelMap())
        }

        Row({ space: 10 }) {
          Button(this.isQT ? 'QT' : 'QR')
            .onClick(() => {
              this.isQT = !this.isQT
              this.themeColor = this.isQT ? '#FFA500' :'#0A59F7'
              this.mDecoder?.setIsQTCode(this.isQT)
              BleManager.getInstance().init();
              BleManager.getInstance()
                .enableLog(true)
                .setReConnectCount(1, 5000)
                .setConnectOverTime(20000)
                .setOperateTimeout(5000);
            })

          Button('å¯åŠ¨Workerè§£ç ')
            .backgroundColor(Color.Green)
            .onClick(() => this.startDecodeWorker())

          Button('åœæ­¢Workerè§£ç ')
            .backgroundColor(Color.Red)
            .onClick(() => this.stopDecodeWorker())
        }

        Row({ space: 10 }) {
          Button('release')
            .backgroundColor(Color.Gray)
            .onClick(() => {
              this.aboutToDisappear()
            })
          Button('æ¸…ç©ºç»“æœ')
            .backgroundColor(Color.Gray)
            .onClick(() => {
              this.testResults = '';
              this.decodeResults = '';
            })
        }

        if (this.mPixelMap) {
          // Image(this.mPixelMap)
          //   .width(200)
          //   .height(200)
          //   .objectFit(ImageFit.Contain)
        }

        // å†™å…¥æµ‹è¯•ç»“æœ
        Text('å†™å…¥æµ‹è¯•ç»“æœ:')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)

        Scroll() {
          Text(this.testResults)
            .fontSize(12)
            .fontFamily('monospace')
            .backgroundColor('#f0f8ff')
            .padding(10)
            .width('100%')
            .textAlign(TextAlign.Start)
        }
        .height(200)
        .width('100%')

        // è§£ç ç»“æœ
        Text('è§£ç ç»“æœ:')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)

        Scroll() {
          Text(this.decodeResults)
            .fontSize(12)
            .fontFamily('monospace')
            .backgroundColor('#f5f5dc')
            .padding(10)
            .width('100%')
            .textAlign(TextAlign.Start)
        }
        .layoutWeight(1)
        .width('100%')
      }
      .padding(0)
      .height('100%')
      .width('100%')

      //ScanningRectEffectCanvas()
    }
  }
}